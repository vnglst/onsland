<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OnsLand - Land Use In Europe</title>
    <link rel="canonical" href="https:/onsland.koenvangilst.nl" />
    <link rel="stylesheet" href="style.css" />
    <script src="lib/d3.v7.min.js"></script>
    <script src="lib/d3-hexbin.v0.2.min.js"></script>
  </head>
  <body>
    <header>
      <h1>
        Land Use in
        <select class="country-dropdown" id="countrySelect">
          <option value="austria">Austria</option>
          <option value="belgium">Belgium</option>
          <option value="croatia">Croatia</option>
          <option value="denmark">Denmark</option>
          <option value="finland">Finland</option>
          <option value="france">France</option>
          <option value="germany">Germany</option>
          <option value="ireland">Ireland</option>
          <option value="italy">Italy</option>
          <option value="netherlands">The Netherlands</option>
          <option value="portugal">Portugal</option>
          <option value="spain">Spain</option>
          <option value="sweden">Sweden</option>
          <option value="uk">United Kingdom</option>
        </select>
      </h1>
      <button class="toggle-button" id="layoutToggle">Square View</button>
    </header>
    <svg viewBox="0 0 800 800" preserveAspectRatio="xMidYMid"></svg>
    <script src="countries.js"></script>
    <script>
      // Development mode: set to true to enable drag-and-drop label positioning
      const DEV_MODE = true;

      // Get country from URL query parameter or default to netherlands
      const urlParams = new URLSearchParams(window.location.search);
      const countryFromUrl = urlParams.get("country");
      const validCountries = [
        "austria",
        "belgium",
        "croatia",
        "denmark",
        "finland",
        "france",
        "germany",
        "ireland",
        "italy",
        "netherlands",
        "portugal",
        "spain",
        "sweden",
        "uk",
      ];
      let currentCountry = validCountries.includes(countryFromUrl) ? countryFromUrl : "netherlands";

      // Set dropdown to match URL immediately to prevent flash
      document.getElementById("countrySelect").value = currentCountry;

      let worldData = null;
      let isSquareLayout = false;
      let hexDataGlobal = null;
      let hexColorsGlobal = null;

      // Load world data once
      fetch("lib/countries-50m.json")
        .then((response) => response.json())
        .then((world) => {
          worldData = world;
          renderCountry(currentCountry);
        })
        .catch((error) => console.error("Error loading data:", error));

      // Country dropdown change handler
      const countrySelect = document.getElementById("countrySelect");
      countrySelect.addEventListener("change", (event) => {
        const country = event.target.value;
        if (country === currentCountry) return;

        // Update country and re-render
        currentCountry = country;
        isSquareLayout = false;
        document.getElementById("layoutToggle").textContent = "Square View";

        // Update URL with new country parameter
        const newUrl = new URL(window.location);
        newUrl.searchParams.set("country", country);
        window.history.pushState({}, "", newUrl);

        renderCountry(country);
      });

      // Layout toggle handler
      const layoutToggle = document.getElementById("layoutToggle");
      layoutToggle.addEventListener("click", () => {
        isSquareLayout = !isSquareLayout;
        layoutToggle.textContent = isSquareLayout ? "Map View" : "Square View";
        toggleLayout();
      });

      function renderCountry(countryKey) {
        if (!worldData) return;

        const config = countryConfigs[countryKey];
        const categories = config.categories;
        const labels = config.labels;

        // Clear SVG
        const svg = d3.select("svg");
        svg.selectAll("*").remove();

        const width = 800;
        const height = 800;
        const hexRadius = 6;

        const projection = d3
          .geoMercator()
          .center(config.center)
          .scale(config.scale)
          .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        // Convert TopoJSON to GeoJSON
        const countries = topojson.feature(worldData, worldData.objects.countries);

        // Find country by ISO code
        const countryFeature = countries.features.find((d) => d.id === config.isoCode);

        if (!countryFeature) {
          console.error(`Country ${countryKey} not found in dataset`);
          return;
        }

        const hexbin = d3
          .hexbin()
          .radius(hexRadius)
          .extent([
            [0, 0],
            [width, height],
          ]);

        const hexCenters = [];
        for (let y = hexRadius; y < height; y += hexRadius * 1.5) {
          for (let x = hexRadius; x < width; x += hexRadius * Math.sqrt(3)) {
            hexCenters.push([x, y]);
          }
        }

        const hexPoints = hexCenters.filter((center) => d3.geoContains(countryFeature, projection.invert(center)));
        const hexData = hexbin(hexPoints);
        hexDataGlobal = hexData;

        const totalHexagons = hexData.length;

        const colorScale = d3
          .scaleOrdinal()
          .domain(categories.map((c) => c.name))
          .range(categories.map((c) => c.color));

        let hexColors = [];

        categories.forEach((category) => {
          const hexagonsPerCategory = Math.round(totalHexagons * category.percentage);
          for (let i = 0; i < hexagonsPerCategory; i++) hexColors.push(category.name);
        });

        hexColorsGlobal = hexColors;

        let selectedCategory = null;

        function highlightHexagons(category) {
          svg
            .selectAll(".hexagon")
            .filter((_, i) => hexColors[i] === category)
            .classed("highlight", true);
          svg
            .selectAll(".legend-item")
            .filter((_, i) => categories[i].name !== category)
            .classed("dimmed", true);
          svg
            .selectAll(".legend-item")
            .filter((_, i) => categories[i].name === category)
            .classed("dimmed", false);
        }

        function deselectHexagons() {
          svg.selectAll(".hexagon").classed("highlight", false);
          svg.selectAll(".legend-item").classed("dimmed", false);
          selectedCategory = null;
        }

        // Draw hexagons
        svg
          .append("g")
          .selectAll("path")
          .data(hexData)
          .enter()
          .append("path")
          .attr("class", "hexagon")
          .attr("d", (d) => hexbin.hexagon(0))
          .attr("transform", (d) => `translate(${d.x},${d.y - Math.random() * 200})`)
          .attr("fill", "var(--bg-light)")
          .on("mouseenter", function (event, d) {
            const category = hexColors[hexData.indexOf(d)];
            highlightHexagons(category);
          })
          .on("mouseleave", function (event, d) {
            if (!selectedCategory) {
              deselectHexagons();
            }
          })
          .on("click", function (event, d) {
            const category = hexColors[hexData.indexOf(d)];
            if (selectedCategory === category) {
              deselectHexagons();
            } else {
              deselectHexagons();
              highlightHexagons(category);
              selectedCategory = category;
            }
            event.stopPropagation();
            event.preventDefault();
          })
          .transition()
          .delay((d, i) => i * 0.7)
          .duration(750)
          .ease(d3.easeCubicOut)
          .attr("fill", (d, i) => colorScale(hexColors[i]))
          .attr("transform", (d) => `translate(${d.x},${d.y})`)
          .attr("d", (d) => hexbin.hexagon(hexRadius));

        d3.select("body").on("click", function () {
          if (selectedCategory !== null) {
            deselectHexagons();
          }
        });

        // Determine legend position based on config
        const legendPosition = config.legendPosition || "top";
        let legendY = 5; // default top position
        if (legendPosition === "bottom") {
          // Calculate bottom position: height - (number of categories * 20px per item) - padding
          legendY = height - categories.length * 20 - 120;
        }

        const legend = svg.append("g").attr("transform", `translate(5, ${legendY})`);

        categories.forEach((category, i) => {
          const legendItem = legend
            .append("g")
            .attr("transform", `translate(0, ${i * 20})`)
            .attr("class", `legend-item ${category.name.replace(/\s+/g, "-")}`);

          legendItem
            .append("path")
            .attr("d", hexbin.hexagon(hexRadius))
            .attr("transform", "translate(5,5)")
            .style("fill", category.color)
            .attr("opacity", 0)
            .transition()
            .delay(i * 40)
            .duration(500)
            .attr("opacity", 1);

          legendItem
            .append("text")
            .attr("x", 20)
            .attr("y", 10)
            .text(`${category.name}, ${(category.percentage * 100).toFixed(2)}%`)
            .attr("font-size", "14px")
            .attr("fill", "var(--text-light)")
            .attr("opacity", 0)
            .transition()
            .delay(i * 40)
            .duration(500)
            .attr("opacity", 1);
        });

        labels
          .filter((c) => c.displayLabel)
          .forEach((category, i) => {
            const labelGroup = svg;

            // Label text
            const labelText = labelGroup
              .append("text")
              .attr("x", category.labelPosition.x)
              .attr("y", category.labelPosition.y)
              .text(category.label)
              .attr("font-size", "18px")
              .attr("fill", "var(--text-light)")
              .attr("font-weight", "bold")
              .attr("opacity", 0)
              .attr("data-label", category.label)
              .attr("data-type", "position");

            // Line connecting label to target (always visible)
            const line = labelGroup
              .append("line")
              .attr("x1", category.labelPosition.x - 10)
              .attr("y1", category.labelPosition.y - 5)
              .attr("x2", category.labelTarget.x - 10)
              .attr("y2", category.labelTarget.y - 5)
              .attr("stroke", "var(--text-light)")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "2,2")
              .attr("opacity", 0)
              .attr("data-label", category.label);

            line
              .transition()
              .delay(totalHexagons * 0.7 + 750 + i * 300)
              .duration(500)
              .attr("opacity", 1);

            // Target circle (always visible)
            const targetCircle = labelGroup
              .append("circle")
              .attr("cx", category.labelTarget.x - 10)
              .attr("cy", category.labelTarget.y - 5)
              .attr("r", 5)
              .attr("fill", "var(--text-light)")
              .attr("opacity", 0)
              .attr("data-label", category.label)
              .attr("data-type", "target");

            targetCircle
              .transition()
              .delay(totalHexagons * 0.7 + 750 + i * 300)
              .duration(500)
              .attr("opacity", 1);

            // Label position circle (always visible)
            const positionCircle = labelGroup
              .append("circle")
              .attr("cx", category.labelPosition.x - 10)
              .attr("cy", category.labelPosition.y - 5)
              .attr("r", 5)
              .attr("fill", "var(--text-light)")
              .attr("opacity", 0)
              .attr("data-label", category.label)
              .attr("data-type", "position");

            positionCircle
              .transition()
              .delay(totalHexagons * 0.7 + 750 + i * 300)
              .duration(500)
              .attr("opacity", 1);

            // Only add drag functionality in dev mode
            if (DEV_MODE) {
              // Add drag behavior to position elements
              const dragPosition = d3
                .drag()
                .on("drag", function (event) {
                  const label = d3.select(this).attr("data-label");
                  const newX = event.x;
                  const newY = event.y;

                  // Update position circle
                  svg
                    .selectAll(`circle[data-label="${label}"][data-type="position"]`)
                    .attr("cx", newX - 10)
                    .attr("cy", newY - 5);

                  // Update text position
                  svg.selectAll(`text[data-label="${label}"]`).attr("x", newX).attr("y", newY);

                  // Update line
                  svg
                    .selectAll(`line[data-label="${label}"]`)
                    .attr("x1", newX - 10)
                    .attr("y1", newY - 5);
                })
                .on("end", function () {
                  printLabelCoordinates();
                });

              // Add drag behavior to target circle
              const dragTarget = d3
                .drag()
                .on("drag", function (event) {
                  const label = d3.select(this).attr("data-label");
                  const newX = event.x;
                  const newY = event.y;

                  // Update target circle
                  svg
                    .selectAll(`circle[data-label="${label}"][data-type="target"]`)
                    .attr("cx", newX - 10)
                    .attr("cy", newY - 5);

                  // Update line
                  svg
                    .selectAll(`line[data-label="${label}"]`)
                    .attr("x2", newX - 10)
                    .attr("y2", newY - 5);
                })
                .on("end", function () {
                  printLabelCoordinates();
                });

              labelText.attr("cursor", "move").call(dragPosition);
              positionCircle.attr("cursor", "move").call(dragPosition);
              targetCircle.attr("cursor", "move").call(dragTarget);
            }

            labelText
              .transition()
              .delay(totalHexagons * 0.7 + 750 + i * 300)
              .duration(500)
              .attr("opacity", 1);
          });

        // Function to print current label coordinates
        function printLabelCoordinates() {
          const coordinates = [];

          labels.forEach((label) => {
            const textEl = svg.select(`text[data-label="${label.label}"]`);
            const targetEl = svg.select(`circle[data-label="${label.label}"][data-type="target"]`);

            if (!textEl.empty() && !targetEl.empty()) {
              const posX = parseFloat(textEl.attr("x"));
              const posY = parseFloat(textEl.attr("y"));
              const targetX = parseFloat(targetEl.attr("cx")) + 10;
              const targetY = parseFloat(targetEl.attr("cy")) + 5;

              coordinates.push({
                label: label.label,
                displayLabel: true,
                labelTarget: { x: Math.round(targetX), y: Math.round(targetY) },
                labelPosition: { x: Math.round(posX), y: Math.round(posY) },
              });
            }
          });

          console.log(`\n=== ${countryKey} Label Coordinates (JSON) ===`);
          console.log(JSON.stringify(coordinates, null, 2));
          console.log("===============================================\n");
        }

        svg
          .append("foreignObject")
          .attr("x", 25)
          .attr("y", height - 50)
          .attr("width", 760)
          .attr("height", 30)
          .attr("font-size", "12px")
          .append("xhtml:div")
          .html(
            `Data: <a target="_blank" href="https://ec.europa.eu/eurostat/databrowser/view/lan_lcv_ovw/default/table">Eurostat Land Cover</a>`
          );

        svg
          .append("foreignObject")
          .attr("x", 180)
          .attr("y", height - 50)
          .attr("width", 760)
          .attr("height", 30)
          .attr("font-size", "12px")
          .append("xhtml:div")
          .html(`| Code: <a target="_blank" href="https://github.com/vnglst/onsland">Github</a>`);

        svg
          .append("foreignObject")
          .attr("x", 25)
          .attr("y", height - 30)
          .attr("width", 760)
          .attr("height", 30)
          .attr("font-size", "12px")
          .append("xhtml:div")
          .html(`Visualisation by <a target="_blank" href="https://koenvangilst.nl/labs/ons-land">Koen van Gilst</a>`);
      }

      // Generate a square path
      function squarePath(size) {
        const half = size / 2;
        return `M ${-half},${-half} L ${half},${-half} L ${half},${half} L ${-half},${half} Z`;
      }

      // Calculate square grid positions
      function calculateSquarePositions(totalHexagons) {
        const width = 800;
        const height = 800;
        const squareSize = 10; // Size of each square
        const padding = 50;

        // Calculate how many squares can fit in a row
        const availableWidth = width - padding * 2;
        const availableHeight = height - padding * 2;

        // Try to make it as square as possible
        const cols = Math.ceil(Math.sqrt(totalHexagons * (availableWidth / availableHeight)));
        const rows = Math.ceil(totalHexagons / cols);

        // Center the grid
        const gridWidth = cols * squareSize;
        const gridHeight = rows * squareSize;
        const offsetX = (width - gridWidth) / 1.5 + squareSize / 2;
        const offsetY = squareSize;

        const positions = [];
        for (let i = 0; i < totalHexagons; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;
          const x = offsetX + col * squareSize;
          const y = offsetY + row * squareSize;
          positions.push({ x, y });
        }

        return positions;
      }

      // Toggle between map and square layout
      function toggleLayout() {
        const svg = d3.select("svg");
        const hexRadius = 6;
        const squareSize = 10;

        if (isSquareLayout) {
          // Animate to square layout
          const squarePositions = calculateSquarePositions(hexDataGlobal.length);

          svg
            .selectAll(".hexagon")
            .transition()
            .duration(1000)
            .ease(d3.easeCubicInOut)
            .attr("transform", (d, i) => {
              const pos = squarePositions[i];
              return `translate(${pos.x},${pos.y})`;
            })
            .attr("d", squarePath(squareSize))
            .attr("stroke-width", 0);

          // Hide labels in square view
          svg
            .selectAll("text[data-label], line[data-label], circle[data-label]")
            .transition()
            .duration(500)
            .attr("opacity", 0);
        } else {
          // Animate back to map layout
          const hexbin = d3.hexbin().radius(hexRadius);

          svg
            .selectAll(".hexagon")
            .transition()
            .duration(1000)
            .ease(d3.easeCubicInOut)
            .attr("transform", (d, i) => `translate(${hexDataGlobal[i].x},${hexDataGlobal[i].y})`)
            .attr("d", hexbin.hexagon(hexRadius))
            .attr("stroke-width", 0.1);

          // Show labels in map view
          svg
            .selectAll("text[data-label], line[data-label], circle[data-label]")
            .transition()
            .delay(500)
            .duration(500)
            .attr("opacity", 1);
        }
      }
    </script>
    <!-- TopoJSON library for converting topojson to geojson -->
    <script src="lib/topojson-client.v3.min.js"></script>
  </body>
</html>
